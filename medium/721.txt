721. 账户合并给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。 示例 1：输入：accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]输出：[["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]解释：第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 "johnsmith@mail.com"。 第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。可以以任何顺序返回这些列表，例如答案 [['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']，['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']] 也是正确的。 提示：accounts的长度将在[1，1000]的范围内。accounts[i]的长度将在[1，10]的范围内。accounts[i][j]的长度将在[1，30]的范围内。通过次数11,153提交次数26,767class Solution {    private:        // f记录每个人名的父辈是谁        // isAppeared保存已经出现过的邮箱地址        // father记录每个邮箱的父辈是谁        vector<int> f;        unordered_set<string> isAppeared;        unordered_map<string, int> father;    public:        // 并查集的通用代码，find(x)查找父辈        int find(int x)        {            return x == f[x] ? x : find(f[x]);        }        // 并查集的通用代码，merge(x, y)合并父辈        void merge(int x, int y)        {            int xFather = find(x);            int yFather = find(y);            if(xFather != yFather) f[yFather] = xFather;        }        vector<vector<string>> accountsMerge(vector<vector<string>>& accounts)         {            // 定义res作为最后的返回结果            vector<vector<string>> res;            // 初始化f，所有人名初始默认自身为父辈            f = vector<int>(accounts.size());            for(int i=0; i < f.size(); i++) f[i] = i;            // 遍历每个人名下的每个邮箱，遍历结束后会得到更新后的父辈关系表f            for(int i=0; i < accounts.size(); i++)            {                for(int j=1; j < accounts[i].size(); j++)                {                    // 判断该邮箱是否是第一次出现                    //   1. 若是，将其加入isAppeared；因为人名会出现重复，改为记录第一次出现该邮箱的人名的位置                    //   2. 若不是，说明邮箱已经被使用了，那么这两个人是同一个人，所以要改变当前人名的父辈关系，即合并                    if(!isAppeared.count(accounts[i][j]))                    {                        isAppeared.insert(accounts[i][j]);                        father[accounts[i][j]] = i;                    }                    else                    {                        merge(father[accounts[i][j]], i);                    }                }            }            // 遍历accounts中每个人名，寻找每个人名的父辈，并将该人名下所有邮箱保存到一起            // 由于会存在重复邮箱，且要考虑邮箱顺序，所以使用set<string>来去重并内部自动排序            unordered_map<int, set<string>> accMail;            for(int i=0; i < accounts.size(); i++)            {                int t = find(i);                int len = accounts[i].size();                for(int j=1; j < len; j++) accMail[t].insert(accounts[i][j]);            }            // 遍历accMail，其中每一项为<人名位置， 该人名下所有的邮箱>            // 将其转化为题目需要的返回格式            for(auto acc: accMail)            {                vector<string> ans;                ans.push_back(accounts[acc.first][0]);                for(auto mail: acc.second) ans.push_back(mail);                res.push_back(ans);            }            return res;        }};